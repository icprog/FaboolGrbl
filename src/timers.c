//-----------------------------------------------------------------------------
/*

Timer Functions

Setup the hardware timers for:

* The generation of stepper motor pulses
* The generation of periodic callbacks to the cdc interface
* The generation of the G540 charge pump signal

*/
//-----------------------------------------------------------------------------

#include "stm32f2xx_hal.h"
#include "timers.h"
#include "stepper.h"

//-----------------------------------------------------------------------------
uint32_t ui_cdc_timer_count;
//-----------------------------------------------------------------------------

// enable the peripheral clock for the timers
static void enable_tim_clock(TIM_TypeDef *tim)
{
    if (tim == TIM2) {
        RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
    } else if (tim == TIM3) {
        RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
    } else if (tim == TIM4) {
        RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
    }
}

// enable timer interrupts
// set the preempt and sub priority
static void enable_tim_interrupt(TIM_TypeDef *tim, uint32_t pre, uint32_t sub)
{
    uint32_t irq;

    if (tim == TIM2) {
        irq = TIM2_IRQn;
    } else if (tim == TIM3) {
        irq = TIM3_IRQn;
    } else if (tim == TIM4) {
        irq = TIM4_IRQn;
    } else {
        return;
    }

    HAL_NVIC_SetPriority(irq, pre, sub);
    NVIC_EnableIRQ(irq);
}

//-----------------------------------------------------------------------------
// Use TIM2 to generate stepper motor timing pulses
// Output is generated by interrupts and GPIO control in the ISRs.
// channel1 - generates delay from direction change to start of step pulse
// channel2 - generates the step pulse duration
// timer period - generates the total step period

#define STEP_TIMER TIM2

static void step_timer_init(void)
{
    TIM_TypeDef* const TIMx = STEP_TIMER;

    // enable the peripheral clock
    enable_tim_clock(TIMx);

    // up counter, edge aligned mode, arr is not buffered
    TIMx->CR1 = 0;
    TIMx->CR2 = 0;
    // slave mode control register (not used)
    TIMx->SMCR = 0;
    // disable and clear interrupts (for now)
    TIMx->DIER = 0;
    TIMx->SR = 0;
    // setup the output control mode (no output, no CCR preload)
    TIMx->CCMR1 = 0;
    TIMx->CCMR2 = 0;
    // disable output
    TIMx->CCER = 0;
    // setup the counter, reload value and prescalar
    TIMx->CNT = 0;
    TIMx->PSC = ((SystemCoreClock / 2) /(TICKS_PER_MICROSECOND * 1000000)) - 1;
    TIMx->ARR = 0;
    // setup the output compare values (0 for now)
    TIMx->CCR1 = 0;
    TIMx->CCR2 = 0;
    TIMx->CCR3 = 0;
    TIMx->CCR4 = 0;
    // dma is not used
    TIMx->DCR = 0;
    TIMx->DMAR = 0;

    // Enable the interrupt - run this at high priority.
    // we don't want other interrupts altering the step timing.
    enable_tim_interrupt(TIMx, 0, 0);
}

void step_isr_enable(void)
{
    TIM_TypeDef* const TIMx = STEP_TIMER;
    uint32_t enable = TIM_DIER_UIE;

    // enable interrupts
    if (TIMx->CCR1) {
        // the dirn to step pulse delay is non-zero, enable channel 1
         enable |= TIM_DIER_CC1IE;
    }
    if (TIMx->CCR2) {
        // the step pulse is non-zero, enable channel 2
         enable |= TIM_DIER_CC2IE;
    }
    TIMx->DIER |= enable;

    // turn on the timer
    TIMx->CR1 |= TIM_CR1_CEN;
}

void step_isr_disable(void)
{
    TIM_TypeDef* const TIMx = STEP_TIMER;
    // turn off the timer
    TIMx->CR1 &= ~TIM_CR1_CEN;
    // disable interrupts (updates, channel1, channel2)
    TIMx->DIER &= ~(TIM_DIER_UIE | TIM_DIER_CC1IE | TIM_DIER_CC2IE);
}

void set_step_period(uint32_t ticks)
{
    TIM_TypeDef* const TIMx = STEP_TIMER;
    uint32_t saved = TIMx->CR1 & TIM_CR1_CEN;
    TIMx->CR1 &= ~TIM_CR1_CEN;
    TIMx->ARR = ticks;
    if (TIMx->CNT >= ticks) {
        TIMx->CNT = ticks;
    }
    TIMx->CR1 |= saved;
}

void set_step_pulse_delay(uint32_t ticks)
{
    TIM_TypeDef* const TIMx = STEP_TIMER;
    TIMx->CCR1 = ticks;
}

void set_step_pulse_time(uint32_t ticks)
{
    TIM_TypeDef* const TIMx = STEP_TIMER;
    TIMx->CCR2 = ticks;
}

void TIM2_IRQHandler(void)
{
    TIM_TypeDef* const TIMx = STEP_TIMER;

    if ((TIMx->SR & TIM_SR_CC1IF) && (TIMx->DIER & TIM_DIER_CC1IE)) {
        TIMx->SR &= ~TIM_SR_CC1IF;
        step_delay_isr();
    }

    if ((TIMx->SR & TIM_SR_CC2IF) && (TIMx->DIER & TIM_DIER_CC2IE)) {
        TIMx->SR &= ~TIM_SR_CC2IF;
        step_pulse_isr();
    }

    if ((TIMx->SR & TIM_SR_UIF) && (TIMx->DIER & TIM_DIER_UIE)) {
        TIMx->SR &= ~TIM_SR_UIF;
        step_period_isr();
    }
}

//-----------------------------------------------------------------------------
#define LASER_TIMER TIM3
#define LASER_TIMER_HZ1 122
#define LASER_TIMER_HZ2 488
#define LASER_TIMER_HZ3 3906

static void laser_timer_init(void)
{
    TIM_TypeDef* const TIMx = LASER_TIMER;

    // enable the peripheral clock
    enable_tim_clock(TIMx);

    // up counter, edge aligned mode, arr is buffered
    TIMx->CR1 = 0;
    TIMx->CR2 = 0;
    // slave mode control register (not used)
    TIMx->SMCR = 0;
    // disable and clear interrupts
    TIMx->DIER = 0;
    TIMx->SR = 0;
    // setup the output control mode
    TIMx->CCMR1 = 0;
    TIMx->CCMR2 = TIM_CCMR2_OC3M_2 | TIM_CCMR2_OC3M_1;
    // disable any output (for now)
    TIMx->CCER = 0;
    // setup the counter, reload value and prescalar
    TIMx->CNT = 0;
    TIMx->PSC = ((SystemCoreClock / 2) / (LASER_TIMER_HZ1 * LASER_TIMER_PERIOD)) - 1;
    TIMx->ARR = LASER_TIMER_PERIOD - 1;
    // setup the output compare values (channel2 only)
    TIMx->CCR1 = 0;
    TIMx->CCR2 = 0;
    TIMx->CCR3 = 0;
    TIMx->CCR4 = 0;
    // dma is not used
    TIMx->DCR = 0;
    TIMx->DMAR = 0;

    // generate update event to load registers
    TIMx->EGR = TIM_EGR_UG;

    // turn on the channel3 output compare
    TIMx->CCER |= TIM_CCER_CC3E;
    // turn on the timer
    TIMx->CR1 |= TIM_CR1_CEN;
}

void control_laser_intensity(uint8_t intensity) {

    TIM_TypeDef* const TIMx = LASER_TIMER;

    TIMx->CCR3 = intensity;
}
void control_laser_pwm(uint8_t intensity) {

    TIM_TypeDef* const TIMx = LASER_TIMER;

	if (intensity > 40) {
		// set PWM freq to 3.9kHz
	    TIMx->PSC = ((SystemCoreClock / 2) / (LASER_TIMER_HZ3 * LASER_TIMER_PERIOD)) - 1;
	} else if (intensity > 10) {
		// set PWM freq to 489Hz
	    TIMx->PSC = ((SystemCoreClock / 2) / (LASER_TIMER_HZ2 * LASER_TIMER_PERIOD)) - 1;
	} else {
		// set PWM freq to 122Hz
	    TIMx->PSC = ((SystemCoreClock / 2) / (LASER_TIMER_HZ1 * LASER_TIMER_PERIOD)) - 1;
	}
}

//-----------------------------------------------------------------------------
// Generate a periodic callback to the CDC interface

#define CDC_TIMER TIM4
#define CDC_TIMER_HZ 100
#define CDC_TIMER_PERIOD 5000

static void cdc_timer_init(void)
{
    TIM_TypeDef* const TIMx = CDC_TIMER;

	ui_cdc_timer_count = 0;

    // enable the peripheral clock
    enable_tim_clock(TIMx);

    // up counter, edge aligned mode, arr is buffered
    TIMx->CR1 = TIM_CR1_ARPE;
    TIMx->CR2 = 0;
    // slave mode control register (not used)
    TIMx->SMCR = 0;
    // disable and clear interrupts
    TIMx->DIER = 0;
    TIMx->SR = 0;
    // no output/input control
    TIMx->CCMR1 = 0;
    TIMx->CCMR2 = 0;
    TIMx->CCER = 0;
    // setup the counter, reload value and prescalar
    TIMx->CNT = 0;
    TIMx->PSC = ((SystemCoreClock / 2) /(CDC_TIMER_PERIOD * CDC_TIMER_HZ)) - 1;
    TIMx->ARR = CDC_TIMER_PERIOD - 1;
    // no output compare values
    TIMx->CCR1 = 0;
    TIMx->CCR2 = 0;
    TIMx->CCR3 = 0;
    TIMx->CCR4 = 0;
    // dma is not used
    TIMx->DCR = 0;
    TIMx->DMAR = 0;

    // generate update event to load registers
    TIMx->EGR = TIM_EGR_UG;

    // enable the interrupt - run this at low priority.
//    enable_tim_interrupt(TIMx, 4, 0);
    enable_tim_interrupt(TIMx, 1, 0);
}

void cdc_timer_start(void)
{
    TIM_TypeDef* const TIMx = CDC_TIMER;

	ui_cdc_timer_count = 0;

    // enable update interrupts
    TIMx->DIER |= TIM_DIER_UIE;
    // turn on the timer
    TIMx->CR1 |= TIM_CR1_CEN;
}
void cdc_timer_stop(void)
{
    TIM_TypeDef* const TIMx = CDC_TIMER;

    // turn off the timer
    TIMx->CR1 &= ~TIM_CR1_CEN;
    // disable interrupts
    TIMx->DIER &= ~TIM_DIER_UIE;
}

void TIM4_IRQHandler(void)
{
    TIM_TypeDef* const TIMx = CDC_TIMER;

    if ((TIMx->SR & TIM_SR_UIF) && (TIMx->DIER & TIM_DIER_UIE)) {
        TIMx->SR &= ~TIM_SR_UIF;
        cdc_timer_isr();
    }
}
//-----------------------------------------------------------------------------
void timers_init(void)
{
    step_timer_init();
    laser_timer_init();
    cdc_timer_init();
}
//-----------------------------------------------------------------------------
