/*
  stepper.c - stepper motor pulse generation
  Processes block from the queue generated by the planer and pulses
  steppers accordingly via a dynamically adapted timer interrupt.
  Part of LasaurGrbl

  Copyright (c) 2011 Stefan Hechenberger
  Copyright (c) 2009-2011 Simen Svale Skogsrud
  Copyright (c) 2011 Sungeun K. Jeon

  Inspired by the 'RepRap cartesian firmware' by Zack Smith and
  Philipp Tiefenbacher.

  LasaurGrbl is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  LasaurGrbl is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  ---

           __________________________
          /|                        |\     _________________         ^
         / |                        | \   /|               |\        |
        /  |                        |  \ / |               | \       s
       /   |                        |   |  |               |  \      p
      /    |                        |   |  |               |   \     e
     +-----+------------------------+---+--+---------------+----+    e
     |               BLOCK 1            |      BLOCK 2          |    d

                             time ----->

  The speed profile starts at block->initial_rate, accelerates by block->rate_delta
  during the first block->accelerate_until step_events_completed, then keeps going at constant speed until
  step_events_completed reaches block->decelerate_after after which it decelerates until final_rate is reached.
  The slope of acceleration is always +/- block->rate_delta and is applied at a constant rate following the midpoint rule.
  Speed adjustments are made ACCELERATION_TICKS_PER_SECOND times per second.
*/


#include "stm32f2xx_hal.h"
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "stepper.h"
#include "config.h"
#include "gcode.h"
#include "planner.h"
#include "gpio.h"
#include "i2c.h"
#include "timers.h"
#include "delay.h"


#define CYCLES_PER_ACCELERATION_TICK ((TICKS_PER_MICROSECOND*1000000)/ACCELERATION_TICKS_PER_SECOND)


#define DEFAULT_STEPPING_INVERT_MASK 0
#define DEFAULT_DIR_INVERT_MASK (GPIO_BIT(DIR_X) | GPIO_BIT(DIR_Y))

//#define STEP_PULSE_DELAY 5 // Step pulse delay in microseconds. Default disabled.

static uint16_t step_bits;          // step bits
static uint16_t dirn_bits;          // direction bits
static uint16_t saved_step_bits;    // saved step bits


static int32_t stepper_position[3];  // real-time position in absolute steps
static block_t *current_block;  // A pointer to the block currently being traced

// Variables used by The Stepper Driver Interrupt
static int32_t counter_x,       // Counter variables for the bresenham line tracer
               counter_y;
static uint32_t step_events_completed; // The number of step events executed in the current block
static volatile uint8_t busy;  // true whe stepper ISR is in already running

// Variables used by the trapezoid generation
static uint32_t cycles_per_step_event;        // The number of machine cycles between each step event
static uint32_t acceleration_tick_counter;    // The cycles since last acceleration_tick.
                                              // Used to generate ticks at a steady pace without allocating a separate timer.
static uint32_t adjusted_rate;                // The current rate of step_events according to the speed profile
static bool processing_flag;                  // indicates if blocks are being processed
static volatile bool stop_requested;          // when set to true stepper interrupt will go idle on next entry
static volatile uint8_t stop_status;          // yields the reason for a stop request


// prototypes for static functions (non-accesible from other files)
static bool acceleration_tick();
static void adjust_speed( uint32_t steps_per_minute );


// Initialize and start the stepper motor subsystem
void stepper_init() {
  // Configure directions of interface pins
  step_wr(DEFAULT_STEPPING_INVERT_MASK);

  // Enable the stepper motors
#if GRBL_MODEL == FABOOL_LASER_MC
  driver_current_enable(700, 700);
#else
  driver_current_enable(400, 700);
#endif
  stepper_motor_enable();

  adjust_speed(MINIMUM_STEPS_PER_MINUTE);
  clear_vector(stepper_position);
  stepper_set_position( CONFIG_X_ORIGIN_OFFSET,
                        CONFIG_Y_ORIGIN_OFFSET,
                        CONFIG_Z_ORIGIN_OFFSET );
  acceleration_tick_counter = 0;
  current_block = NULL;
  stop_requested = false;
  stop_status = STATUS_OK;
  busy = false;

  // start in the idle state
  // The stepper interrupt gets started when blocks are being added.
  stepper_go_idle();
}


// block until all command blocks are executed
void stepper_synchronize() {
  while(processing_flag) {
    // sleep_mode();
  }
}


// start processing command blocks
void stepper_wake_up() {
  if (!processing_flag) {
    processing_flag = true;

    // Initialize stepper output bits
    step_bits = DEFAULT_STEPPING_INVERT_MASK;
    dirn_bits = DEFAULT_DIR_INVERT_MASK;
    // Initialize step pulse timing from settings. Here to ensure updating after re-writing.
#ifdef STEP_PULSE_DELAY
    set_step_pulse_delay(STEP_PULSE_DELAY * TICKS_PER_MICROSECOND);
    set_step_pulse_time((CONFIG_PULSE_MICROSECONDS + STEP_PULSE_DELAY) * TICKS_PER_MICROSECOND);
#else // Normal operation
    set_step_pulse_delay(0);
    set_step_pulse_time(CONFIG_PULSE_MICROSECONDS * TICKS_PER_MICROSECOND);
#endif
    // Enable stepper driver interrupt
    step_isr_enable();
  }
}


// stop processing command blocks
void stepper_go_idle() {
  // Disable stepper driver interrupt
  step_isr_disable();

  processing_flag = false;
  current_block = NULL;
  control_laser_intensity(0);
}

// stop event handling
void stepper_request_stop(uint8_t status) {
  stop_status = status;
  stop_requested = true;
}

uint8_t stepper_stop_status() {
  return stop_status;
}

bool stepper_stop_requested() {
  return stop_requested;
}

void stepper_stop_resume() {
  stop_requested = false;
}




int32_t stepper_get_x() {
  return stepper_position[X_AXIS];
}
int32_t stepper_get_y() {
#if GRBL_MODEL == FABOOL_LASER_MC
  return stepper_position[Y_AXIS] - stepper_position[X_AXIS];
#else
  return stepper_position[Y_AXIS];
#endif
}
int32_t stepper_get_z() {
  return stepper_position[Z_AXIS];
}
double stepper_get_position_x() {
#if GRBL_MODEL == FABOOL_LASER_MC
  double s1 = (stepper_position[X_AXIS] / CONFIG_X_STEPS_PER_DEG) * M_PI / 180.0;
  double s2 = ((stepper_position[Y_AXIS] - stepper_position[X_AXIS]) / CONFIG_Y_STEPS_PER_DEG) * M_PI / 180.0;

  return 150.0 + CONFIG_R1 * sin(s1) + CONFIG_R2 * sin(s1 + s2);

//  double s1 = stepper_position[X_AXIS] / CONFIG_X_STEPS_PER_DEG;
//  double s2 = (stepper_position[Y_AXIS] - stepper_position[X_AXIS]) / CONFIG_Y_STEPS_PER_DEG;
//
//  double x_pos = cos(SVPOS_TO_RAD(s1)) * AXISLEN_A + cos(SVPOS_TO_RAD(s1 + s2)) * AXISLEN_B - X_OFS;
//  double y_pos = sin(SVPOS_TO_RAD(s1)) * AXISLEN_A + sin(SVPOS_TO_RAD(s1 + s2)) * AXISLEN_B;
//
//  double nx= x_pos;
//  double ny= y_pos;
//
//  x_pos = (nx * cos(BASE_ANGLE / 180.0 * M_PI) - ny * sin(BASE_ANGLE / 180.0 * M_PI)) + BASE_OFFSET_X;
//
//  return -x_pos;
#else
  return stepper_position[X_AXIS]/CONFIG_X_STEPS_PER_MM;
#endif
}
double stepper_get_position_y() {
#if GRBL_MODEL == FABOOL_LASER_MC
  double s1 = (stepper_position[X_AXIS] / CONFIG_X_STEPS_PER_DEG) * M_PI / 180.0;
  double s2 = ((stepper_position[Y_AXIS] - stepper_position[X_AXIS]) / CONFIG_Y_STEPS_PER_DEG) * M_PI / 180.0;

  return -100.0 + CONFIG_R1 * cos(s1) + CONFIG_R2 * cos(s1 + s2);

//  double s1 = stepper_position[X_AXIS] / CONFIG_X_STEPS_PER_DEG;
//  double s2 = (stepper_position[Y_AXIS] - stepper_position[X_AXIS]) / CONFIG_Y_STEPS_PER_DEG;
//
//  double x_pos = cos(SVPOS_TO_RAD(s1)) * AXISLEN_A + cos(SVPOS_TO_RAD(s1 + s2)) * AXISLEN_B - X_OFS;
//  double y_pos = sin(SVPOS_TO_RAD(s1)) * AXISLEN_A + sin(SVPOS_TO_RAD(s1 + s2)) * AXISLEN_B;
//
//  double nx= x_pos;
//  double ny= y_pos;
//
//  y_pos = (nx * sin(BASE_ANGLE / 180.0 * M_PI) + ny * cos(BASE_ANGLE / 180.0 * M_PI)) + BASE_OFFSET_Y;
//
//  return -y_pos;
#else
  return stepper_position[Y_AXIS]/CONFIG_Y_STEPS_PER_MM;
#endif
}
double stepper_get_position_z() {
  return stepper_position[Z_AXIS]/CONFIG_Z_STEPS_PER_MM;
}
void stepper_set_position(double x, double y, double z) {
  stepper_synchronize();  // wait until processing is done
#if GRBL_MODEL == FABOOL_LASER_MC
  double nx, ny, x_2, y_2, r1_2, r2_2, c1, c2, sqrt1, sqrt2, atan_yx, s1, s2;

  nx = x - 150;
  ny = y + 100;
  x_2 = nx * nx;
  y_2 = ny * ny;
  r1_2 = CONFIG_R1 * CONFIG_R1;
  r2_2 = CONFIG_R2 * CONFIG_R2;
  c1 = (x_2 + y_2 + r1_2 - r2_2) / (2 * CONFIG_R1);
  c2 = (x_2 + y_2 - r1_2 + r2_2) / (2 * CONFIG_R2);
  sqrt1 = sqrt(x_2 + y_2 - c1* c1);
  sqrt2 = sqrt(x_2 + y_2 - c2* c2);
//  atan_yx = atan2(nx, ny);
//  if (atan_yx >= 0) {
//    s1 = (atan_yx - atan2(c1, sqrt1)) * 180.0 / M_PI;
//    s2 = (atan2(c1, sqrt1) + atan2(c2, sqrt2)) * 180.0 / M_PI;
//  }
//  else {
//    s1 = (atan_yx + atan2(c1, sqrt1)) * 180.0 / M_PI;
//    s2 = (-atan2(c1, sqrt1) - atan2(c2, sqrt2)) * 180.0 / M_PI;
//  }
  s1 = -1 * ((atan2(ny, nx) - atan2(c1, sqrt1)) * 180.0 / M_PI);
  s2 = 180.0 - ((atan2(c1, sqrt1) + atan2(c2, sqrt2)) * 180.0 / M_PI);

//  double s, nx, ny, s1, s2;
//
//  s = -1.0;
//  nx = -x;
//  ny = -y;
//  nx = (nx * cos(-BASE_ANGLE / 180.0 * M_PI) - ny * sin(-BASE_ANGLE / 180.0 * M_PI)) + X_OFS;
//  ny = (nx * sin(-BASE_ANGLE / 180.0 * M_PI) + ny * cos(-BASE_ANGLE / 180.0 * M_PI));
//  if (hypot(nx, ny) >= AXISLEN_A + AXISLEN_B) {
//    s1 = atan2(ny, nx) / M_PI * 180.0;
//    s2 = 0.0;
//  }
//  else {
//    double a, b;
//    a = acos( (-(nx * nx + ny * ny) + AXISLEN_A * AXISLEN_A + AXISLEN_B * AXISLEN_B) / (2 * AXISLEN_A * AXISLEN_B));
//    b = s * acos( (- AXISLEN_A * AXISLEN_A + AXISLEN_B * AXISLEN_B + (nx * nx + ny * ny)) / (2 * AXISLEN_A * sqrt(nx * nx + ny * ny)));
//
//    if (nx < 0) {
//      if (ny >= 0) {
//        s1 = M_PI + atan(ny / nx) + b;
//      }
//      else {
//        s1 = atan(ny / nx) + b - M_PI;
//      }
//    }
//    else {
//      s1 = atan(ny / nx) + b;
//    }
//    s2 = -(M_PI - a) * s;
//
//    if (s1 != 0.0) {
//      s1 = s1 / M_PI * 180.0;
//    }
//    if (s2 != 0.0) {
//      s2 = s2 / M_PI * 180.0;
//    }
//  }

  stepper_position[X_AXIS] = lround(s1 * CONFIG_X_STEPS_PER_DEG);
  stepper_position[Y_AXIS] = lround(s2 * CONFIG_Y_STEPS_PER_DEG);
#else
  stepper_position[X_AXIS] = floor(x*CONFIG_X_STEPS_PER_MM + 0.5);
  stepper_position[Y_AXIS] = floor(y*CONFIG_Y_STEPS_PER_MM + 0.5);
#endif
  stepper_position[Z_AXIS] = floor(z*CONFIG_Z_STEPS_PER_MM + 0.5);
}


//----------------------------------------------------------------------------
// This ISR is called at the end of the pulse period. We have generated a
// pulse of sufficient width, so now we can set the step line low.

void step_pulse_isr(void)
{
    // Reset stepping pins
    step_wr(DEFAULT_STEPPING_INVERT_MASK);
}

//----------------------------------------------------------------------------
// This ISR is called at the end of the direction to pulse delay period.
// We (possibly) altered the direction pin at the start of the period. Now we
// have delayed a short time and can start the step pulse.

void step_delay_isr(void)
{
    // Begin step pulse.
    step_wr(saved_step_bits);
}


// The Stepper ISR
// This is the workhorse of LasaurGrbl. It is executed at the rate set with
// config_step_timer. It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.
// The bresenham line tracer algorithm controls all three stepper outputs simultaneously.
void step_period_isr(void)
{
// I:Raster Start
    uint32_t raster_index;
    uint8_t intensity;
    uint8_t iPos;
    uint8_t iSifft;
// I:Raster End

  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
  busy = true;


  if (stop_requested) {
    // go idle and absorb any blocks
    stepper_go_idle();
    planner_reset_block_buffer();
    planner_request_position_update();
    gcode_request_position_update();
    busy = false;
    return;
  }

    // stop program when any limit is hit or the e-stop turned the power off
    if (limit_input()) {
      stepper_request_stop(STATUS_LIMIT_HIT);
      busy = false;
      return;
    }

  // Set the direction pins
  dirn_wr(dirn_bits);

#ifdef STEP_PULSE_DELAY
  // save step_bits for use in step_delay_isr()
  saved_step_bits = step_bits;
#else
  // set the step pins
  step_wr(step_bits);
#endif

  // If there is no current block, attempt to pop one from the buffer
  if (current_block == NULL) {
    // Anything in the buffer?
    current_block = planner_get_current_block();
    // if still no block command, go idle, disable interrupt
    if (current_block == NULL) {
      stepper_go_idle();
      busy = false;
      return;
    }
// C:Raster Start
//    if (current_block->type == TYPE_LINE) {  // starting on new line block
    if (current_block->type == TYPE_LINE ||
        current_block->type == TYPE_RASTER_LINE ) {  // starting on new line block
// C:Raster End
      adjusted_rate = current_block->initial_rate;
      acceleration_tick_counter = CYCLES_PER_ACCELERATION_TICK/2; // start halfway, midpoint rule.
      adjust_speed( adjusted_rate ); // initialize cycles_per_step_event
      counter_x = -(current_block->step_event_count >> 1);
      counter_y = counter_x;
      step_events_completed = 0;
    }
  }

  // process current block, populate out_bits (or handle other commands)
  switch (current_block->type) {
// I:Raster Start
    case TYPE_RASTER_LINE:
      raster_index = (step_events_completed * current_block->raster.length) / current_block->step_event_count;
      iPos = raster_index / 8;
      iSifft = raster_index % 8;

      intensity = 0;
      if (current_block->raster.invert == 0 && (current_block->raster.buffer[iPos] & (1 << iSifft))) {
          intensity = current_block->raster.intensity;
      }
      else if (current_block->raster.invert != 0 && !(current_block->raster.buffer[iPos] & (1 << iSifft))) {
          intensity = current_block->raster.intensity;
      }

      if (intensity != current_block->laser_pwm) {
          current_block->laser_pwm = intensity;
          control_laser_intensity(intensity);
      }
      //break;
// I:Raster End
    case TYPE_LINE:
      ////// Execute step displacement profile by bresenham line algorithm
      dirn_bits = current_block->direction_bits;
      step_bits = 0;
      counter_x += current_block->steps_x;
      if (counter_x > 0) {
        step_bits |= GPIO_BIT(STEP_X);
        counter_x -= current_block->step_event_count;
        // also keep track of absolute position
        if (dirn_bits & GPIO_BIT(DIR_X)) {
          stepper_position[X_AXIS] -= 1;
        } else {
          stepper_position[X_AXIS] += 1;
        }
      }
      counter_y += current_block->steps_y;
      if (counter_y > 0) {
        step_bits |= GPIO_BIT(STEP_Y);
        counter_y -= current_block->step_event_count;
        // also keep track of absolute position
        if (dirn_bits & GPIO_BIT(DIR_Y)) {
          stepper_position[Y_AXIS] -= 1;
        } else {
          stepper_position[Y_AXIS] += 1;
        }
      }
      //////

      step_events_completed++;  // increment step count

      // apply stepper invert mask
      step_bits ^= DEFAULT_STEPPING_INVERT_MASK;
      dirn_bits ^= DEFAULT_DIR_INVERT_MASK;

      ////////// SPEED ADJUSTMENT
      if (step_events_completed < current_block->step_event_count) {  // block not finished

        // accelerating
        if (step_events_completed < current_block->accelerate_until) {
          if ( acceleration_tick() ) {  // scheduled speed change
            adjusted_rate += current_block->rate_delta;
            if (adjusted_rate > current_block->nominal_rate) {  // overshot
              adjusted_rate = current_block->nominal_rate;
            }
            adjust_speed( adjusted_rate );
          }

        // deceleration start
        } else if (step_events_completed == current_block->decelerate_after) {
            // reset counter, midpoint rule
            // makes sure deceleration is performed the same every time
            acceleration_tick_counter = CYCLES_PER_ACCELERATION_TICK/2;

        // decelerating
        } else if (step_events_completed >= current_block->decelerate_after) {
          if ( acceleration_tick() ) {  // scheduled speed change
            adjusted_rate -= current_block->rate_delta;
            if (adjusted_rate < current_block->final_rate) {  // overshot
              adjusted_rate = current_block->final_rate;
            }
            adjust_speed( adjusted_rate );
          }

        // cruising
        } else {
          // No accelerations. Make sure we cruise exactly at the nominal rate.
          if (adjusted_rate != current_block->nominal_rate) {
            adjusted_rate = current_block->nominal_rate;
            adjust_speed( adjusted_rate );
          }
        }
      } else {  // block finished
        current_block = NULL;
        planner_discard_current_block();
      }
      ////////// END OF SPEED ADJUSTMENT

      break;

    case TYPE_AIR_ASSIST_ENABLE:
      control_air_assist(true);
      current_block = NULL;
      planner_discard_current_block();
      break;

    case TYPE_AIR_ASSIST_DISABLE:
      control_air_assist(false);
      current_block = NULL;
      planner_discard_current_block();
      break;

    case TYPE_AUX1_ASSIST_ENABLE:
      control_aux1_assist(true);
      current_block = NULL;
      planner_discard_current_block();
      break;

    case TYPE_AUX1_ASSIST_DISABLE:
      control_aux1_assist(false);
      current_block = NULL;
      planner_discard_current_block();
      break;
  }

  busy = false;
}




// This function determines an acceleration velocity change every CYCLES_PER_ACCELERATION_TICK by
// keeping track of the number of elapsed cycles during a de/ac-celeration. The code assumes that
// step_events occur significantly more often than the acceleration velocity iterations.
static bool acceleration_tick() {
  acceleration_tick_counter += cycles_per_step_event;
  if(acceleration_tick_counter > CYCLES_PER_ACCELERATION_TICK) {
    acceleration_tick_counter -= CYCLES_PER_ACCELERATION_TICK;
    return true;
  } else {
    return false;
  }
}

static void adjust_speed( uint32_t steps_per_minute ) {
  // steps_per_minute is typicaly just adjusted_rate
  if (steps_per_minute < MINIMUM_STEPS_PER_MINUTE)
  {
      steps_per_minute = MINIMUM_STEPS_PER_MINUTE;
  }

    cycles_per_step_event = (TICKS_PER_MICROSECOND * 1000000 * 60)/steps_per_minute;
    if (cycles_per_step_event == 0)
    {
        cycles_per_step_event = 1;
    }
    set_step_period(cycles_per_step_event);

  // beam dynamics
// C:Raster Start
//  uint8_t adjusted_intensity = current_block->nominal_laser_intensity *
  uint8_t adjusted_intensity = current_block->laser_pwm *
// C:Raster End
                               ((float)steps_per_minute/(float)current_block->nominal_rate);
  uint8_t constrained_intensity = max(adjusted_intensity, 0);
  control_laser_intensity(constrained_intensity);
  control_laser_pwm(constrained_intensity);

}


static void homing_cycle(bool x_axis, bool y_axis, bool z_axis, bool reverse_direction, uint32_t microseconds_per_pulse) {

  uint32_t step_delay = microseconds_per_pulse - CONFIG_PULSE_MICROSECONDS;
  uint16_t out_step_bits = DEFAULT_STEPPING_INVERT_MASK;
  uint16_t limit_bits;
  uint8_t x_overshoot_count = 6;
  uint8_t y_overshoot_count = 6;

  if (x_axis) { out_step_bits |= GPIO_BIT(STEP_X); }
  if (y_axis) { out_step_bits |= GPIO_BIT(STEP_Y); }

  // Set direction pins
  if (reverse_direction) {
      // Invert direction bits if this is a reverse homing_cycle
      dirn_wr(DEFAULT_DIR_INVERT_MASK);
  }
  else {
      dirn_wr(DIR_MASK ^ DEFAULT_DIR_INVERT_MASK);
  }

  for(;;) {
    limit_bits = limit_input();
    if (reverse_direction) {
      // Invert limit_bits if this is a reverse homing_cycle
      limit_bits ^= LIMIT_MASK;
    }
    if (x_axis && (limit_bits & (1<<X1_LIMIT_BIT))) {
      if(x_overshoot_count == 0) {
        x_axis = false;
        out_step_bits ^= GPIO_BIT(STEP_X);
      } else {
        x_overshoot_count--;
      }
    }
    if (y_axis && (limit_bits & (1<<Y1_LIMIT_BIT))) {
      if(y_overshoot_count == 0) {
        y_axis = false;
        out_step_bits ^= GPIO_BIT(STEP_Y);
      } else {
        y_overshoot_count--;
      }
    }
    if(x_axis || y_axis) {
        step_wr(out_step_bits);
        _delay_us(CONFIG_PULSE_MICROSECONDS);
        step_wr(DEFAULT_STEPPING_INVERT_MASK);
        _delay_us(step_delay);
    } else {
        break;
    }
  }
  clear_vector(stepper_position);
  return;
}

static void approach_limit_switch(bool x, bool y, bool z) {
#if GRBL_MODEL == FABOOL_LASER_MC
  homing_cycle(x, y, z,false, 200);
#else
  homing_cycle(x, y, z,false, 600);
#endif
}

static void leave_limit_switch(bool x, bool y, bool z) {
#if GRBL_MODEL == FABOOL_LASER_MC
  homing_cycle(x, y, z, true, 200);
#else
  homing_cycle(x, y, z, true, 10000);
#endif
}

void stepper_homing_cycle() {
  stepper_synchronize();
  // home the x and y axis
#if GRBL_MODEL == FABOOL_LASER_MC
  leave_limit_switch(true, true, false);
  approach_limit_switch(true, true, false);
  leave_limit_switch(true, true, false);
#else
  approach_limit_switch(true, true, false);
  leave_limit_switch(true, true, false);
#endif
}

void stepper_limit_x_on_cycle()
{
  stepper_synchronize();

  homing_cycle(true, false, false, false, 600);
}
void stepper_limit_x_off_cycle()
{
  stepper_synchronize();

  homing_cycle(true, false, false, true, 600);
}
void stepper_limit_y_on_cycle()
{
  stepper_synchronize();

  homing_cycle(false, true, false, false, 600);
}
void stepper_limit_y_off_cycle()
{
  stepper_synchronize();

  homing_cycle(false, true, false, true, 600);
}
